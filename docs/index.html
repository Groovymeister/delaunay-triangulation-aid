<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clickable D3 Plot with Gridlines</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- Title Section -->
    <section class="hero">
        <div class="container">
            <h1>Delaunay Triangulation Pedagogical Aid</h1>
            <p>A pedagogical aid for understanding Delaunay triangulation, with interactive visualizations and step-by-step explanations to deepen your grasp of computational geometry.</p>

            <h3 class="subheading">What is a Delaunay Triangulation?</h3>
            <p class = "body-text">Delaunay triangulation divides a set of points in a plane into triangles such that no point is inside the circumcircle of any triangle. This is a useful algorithm in computer graphics when creating well-shaped triangles in meshes. It is also useful in terrain modeling when handling geographic data and in networking by ensuring efficient communication paths. </p>
            
            
            <h3 class = "subheading">Delaunay Triangulation: Divide and Conquer Algorithm</h3>
            <p class = "body-text">For our project, we are going to create a pedagogical aid that walks through the process of a divide and conquer algorithm that solves the Delaunay Triangulation problem in O(n log n) time.</p>
        </div>
    </section>

    
    
    <!-- SVG container for the grid -->
     <div class="grid-container">
        <svg id="plot" width="900" height="600" style="border: 1px solid black;"></svg>

         <!-- Buttons container -->
        <div id="buttons-container">
            <button id="clear-button">Clear Points</button>
            <button id="toggle-coords">Toggle Coordinates</button>
            <!-- Input box and Randomize button -->
            <input type="number" id="point-count" placeholder="Enter number of points" min="1" max="100">
            <button id="randomize-button">Randomize</button>
            <button id="generate-button">Generate</button>
            <button id="step-button">Step</button>
    
        </div>
        <pre>
            <code>

                def merge(left_triangulation, right_triangulation):
                    triangulation = left_triangulation.union(right_triangulation)
                    base_lr_edge = lr_edge(edges_to_points(left_triangulation), edges_to_points(right_triangulation))
                    triangulation.add(base_lr_edge)
                    steps.append(("add", base_lr_edge))
                
                    while True:
                        left_removed_edges = set()
                        right_removed_edges = set()
                        left_candidate = None
                        right_candidate = None
                        right_candidates = get_candidates(base_lr_edge, right_triangulation, True)
                        left_candidates = get_candidates(base_lr_edge, left_triangulation, False)
                        
                        
                        # for every potential right candidate, ensure
                        # 1. the angle it makes with the base is less than 180 
                        # 2. the next potential candidate is outside the circumcircle formed with the base edge
                        # ASSUMPTION: If we are looking at the final point, then we do not bother testing for if the next point is within circumcircle
                        while not right_candidate and len(right_candidates) > 0:
                            curr_poss_candidate = right_candidates[0]
                            next_poss_candidate = right_candidates[1] if len(right_candidates) > 1 else None
                            test_angle = clockwise_angle(base_lr_edge.p2, base_lr_edge.p1, base_lr_edge.p2, curr_poss_candidate)
                            if next_poss_candidate and test_angle < math.pi and not is_point_in_circle(base_lr_edge.p1, base_lr_edge.p2, curr_poss_candidate, next_poss_candidate):
                                right_candidate = curr_poss_candidate
                                break
                            elif test_angle < math.pi and not next_poss_candidate:
                                right_candidate = curr_poss_candidate
                            elif test_angle < math.pi:
                                # first holds but second doesnt, remove RR edge from potential candidates, consider next right candidate 
                                triangulation.discard(Edge(base_lr_edge.p2, curr_poss_candidate))
                                steps.append(("remove", Edge(base_lr_edge.p2, curr_poss_candidate)))
                                right_removed_edges.add(Edge(base_lr_edge.p2, curr_poss_candidate))
                                right_candidates.pop(0) 
                            else:
                                break # If the first criteria does not hold, we do not select a right candidate
                
                        while not left_candidate and len(left_candidates) > 0:
                            curr_poss_candidate = left_candidates[0]
                            next_poss_candidate = left_candidates[1] if len(left_candidates) > 1 else None
                            test_angle = clockwise_angle(base_lr_edge.p1, curr_poss_candidate, base_lr_edge.p1, base_lr_edge.p2)
                            if next_poss_candidate and test_angle < math.pi and not is_point_in_circle(base_lr_edge.p1, base_lr_edge.p2, curr_poss_candidate, next_poss_candidate):
                                left_candidate = curr_poss_candidate
                                break
                            elif test_angle < math.pi and not next_poss_candidate:
                                left_candidate = curr_poss_candidate
                            elif test_angle < math.pi:
                                # first holds but second doesnt, remove RR edge from potential candidates, consider next right candidate 
                                triangulation.discard(Edge(base_lr_edge.p1, curr_poss_candidate))
                                steps.append(("remove", Edge(base_lr_edge.p1, curr_poss_candidate)))
                                left_removed_edges.add(Edge(base_lr_edge.p1, curr_poss_candidate))
                                left_candidates.pop(0) 
                            else:
                                break # If the first criteria does not hold, we do not select a left candidate
                        
                        # No candidates were returned, merge complete
                        if not left_candidate and not right_candidate:
                            triangulation.update(left_removed_edges)
                            triangulation.update(right_removed_edges)
                            break
                        # Both candidates were returned, create new lr edge for candidate which forms circumcircle that does not contain other point
                        elif left_candidate and right_candidate:
                            if is_point_in_circle(base_lr_edge.p1, base_lr_edge.p2, right_candidate, left_candidate):
                                new_lr_edge = Edge(left_candidate, base_lr_edge.p2)
                                triangulation.update(right_removed_edges)
                            else:
                                new_lr_edge = Edge(base_lr_edge.p1, right_candidate)
                                triangulation.update(left_removed_edges)
                        # One candiate was returned, create new lr edge
                        elif left_candidate or right_candidate:
                            new_lr_edge = Edge(base_lr_edge.p1, right_candidate) if right_candidate else Edge(left_candidate, base_lr_edge.p2)
                            triangulation.update(left_removed_edges) if right_candidate else triangulation.update(right_removed_edges)
                        else:
                            raise ValueError(f"No new edge was formed")
                        triangulation.add(new_lr_edge)
                        base_lr_edge = new_lr_edge
                        steps.append(("add", base_lr_edge))
                
                    return triangulation
                
                # base case for dividing points
                def base_case(points):
                    edges = set()
                    # if there are only two points, add an edge
                    if len(points) == 2:
                        edges.add(Edge(points[0], points[1]))
                    # if there are three points, add edges between every two points
                    elif len(points) == 3:
                        edges.update([Edge(points[0], points[1]), Edge(points[1], points[2]), Edge(points[2], points[0])])
                
                    steps.append(("initial_edges", edges))
                
                    return edges
            
            def delaunay(points):
                points = sorted(points, key=lambda p: (p.x, p.y))
                if len(points) <= 3:
                    return base_case(points)
            
                midpoint = len(points) // 2
                left_points = points[:midpoint]
                right_points = points[midpoint:]
            
                return merge(delaunay(left_points), delaunay(right_points))
            </code>
        </pre>
            
     </div>
     <br><br><br><br><br>
     <script>
        document.addEventListener("DOMContentLoaded", () => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });
    </script>
    <script src="app.js"></script>
</body>
</html>
